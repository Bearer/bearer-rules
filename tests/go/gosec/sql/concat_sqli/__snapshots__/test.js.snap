// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`go_gosec_sql_concat_sqli test 1`] = `
"{
  "high": [
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 15,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 15,
        "end": 15,
        "column": {
          "start": 15,
          "end": 71
        }
      },
      "sink": {
        "start": 15,
        "end": 15,
        "column": {
          "start": 15,
          "end": 71
        },
        "content": "db.Query(\\"SELECT * FROM foo WHERE name = \\" + os.Args[1])"
      },
      "parent_line_number": 15,
      "snippet": "db.Query(\\"SELECT * FROM foo WHERE name = \\" + os.Args[1])",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_0",
      "old_fingerprint": "3350ddd230bfd667e45a89b42b9b1b39_0",
      "code_extract": "\\trows, err := db.Query(\\"SELECT * FROM foo WHERE name = \\" + os.Args[1])"
    },
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 27,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 27,
        "end": 27,
        "column": {
          "start": 15,
          "end": 71
        }
      },
      "sink": {
        "start": 27,
        "end": 27,
        "column": {
          "start": 15,
          "end": 71
        },
        "content": "db.Query(\\"select * from foo where name = \\" + os.Args[1])"
      },
      "parent_line_number": 27,
      "snippet": "db.Query(\\"select * from foo where name = \\" + os.Args[1])",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_1",
      "old_fingerprint": "3350ddd230bfd667e45a89b42b9b1b39_1",
      "code_extract": "\\trows, err := db.Query(\\"select * from foo where name = \\" + os.Args[1])"
    },
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 39,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 39,
        "end": 39,
        "column": {
          "start": 15,
          "end": 98
        }
      },
      "sink": {
        "start": 39,
        "end": 39,
        "column": {
          "start": 15,
          "end": 98
        },
        "content": "db.QueryContext(context.Background(), \\"select * from foo where name = \\"+os.Args[1])"
      },
      "parent_line_number": 39,
      "snippet": "db.QueryContext(context.Background(), \\"select * from foo where name = \\"+os.Args[1])",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_2",
      "old_fingerprint": "3350ddd230bfd667e45a89b42b9b1b39_2",
      "code_extract": "\\trows, err := db.QueryContext(context.Background(), \\"select * from foo where name = \\"+os.Args[1])"
    },
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 56,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 56,
        "end": 56,
        "column": {
          "start": 15,
          "end": 98
        }
      },
      "sink": {
        "start": 56,
        "end": 56,
        "column": {
          "start": 15,
          "end": 98
        },
        "content": "tx.QueryContext(context.Background(), \\"select * from foo where name = \\"+os.Args[1])"
      },
      "parent_line_number": 56,
      "snippet": "tx.QueryContext(context.Background(), \\"select * from foo where name = \\"+os.Args[1])",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_3",
      "old_fingerprint": "3350ddd230bfd667e45a89b42b9b1b39_3",
      "code_extract": "\\trows, err := tx.QueryContext(context.Background(), \\"select * from foo where name = \\"+os.Args[1])"
    },
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 71,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 71,
        "end": 71,
        "column": {
          "start": 15,
          "end": 75
        }
      },
      "sink": {
        "start": 71,
        "end": 71,
        "column": {
          "start": 15,
          "end": 75
        },
        "content": "db.Query(\\"SELECT * FROM foo\\" + \\"WHERE name = \\" + os.Args[1])"
      },
      "parent_line_number": 71,
      "snippet": "db.Query(\\"SELECT * FROM foo\\" + \\"WHERE name = \\" + os.Args[1])",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_4",
      "old_fingerprint": "3350ddd230bfd667e45a89b42b9b1b39_4",
      "code_extract": "\\trows, err := db.Query(\\"SELECT * FROM foo\\" + \\"WHERE name = \\" + os.Args[1])"
    },
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 142,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 142,
        "end": 142,
        "column": {
          "start": 15,
          "end": 38
        }
      },
      "sink": {
        "start": 142,
        "end": 142,
        "column": {
          "start": 15,
          "end": 38
        },
        "content": "DB.Query(getProfileSql)"
      },
      "parent_line_number": 142,
      "snippet": "DB.Query(getProfileSql)",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_5",
      "old_fingerprint": "3350ddd230bfd667e45a89b42b9b1b39_5",
      "code_extract": "\\trows, err := DB.Query(getProfileSql)"
    }
  ]
}"
`;

exports[`go_gosec_sql_concat_sqli test 2 1`] = `
"{
  "high": [
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 18,
      "full_filename": "/tmp/bearer-scan/main2.go",
      "filename": ".",
      "source": {
        "start": 18,
        "end": 18,
        "column": {
          "start": 15,
          "end": 26
        }
      },
      "sink": {
        "start": 18,
        "end": 18,
        "column": {
          "start": 15,
          "end": 26
        },
        "content": "db.Query(q)"
      },
      "parent_line_number": 18,
      "snippet": "db.Query(q)",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_0",
      "old_fingerprint": "a93104166356c0a2709944f5e9659abf_0",
      "code_extract": "\\trows, err := db.Query(q)"
    },
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 31,
      "full_filename": "/tmp/bearer-scan/main2.go",
      "filename": ".",
      "source": {
        "start": 31,
        "end": 31,
        "column": {
          "start": 15,
          "end": 26
        }
      },
      "sink": {
        "start": 31,
        "end": 31,
        "column": {
          "start": 15,
          "end": 26
        },
        "content": "db.Query(q)"
      },
      "parent_line_number": 31,
      "snippet": "db.Query(q)",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_1",
      "old_fingerprint": "a93104166356c0a2709944f5e9659abf_1",
      "code_extract": "\\trows, err := db.Query(q)"
    },
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 44,
      "full_filename": "/tmp/bearer-scan/main2.go",
      "filename": ".",
      "source": {
        "start": 44,
        "end": 44,
        "column": {
          "start": 15,
          "end": 55
        }
      },
      "sink": {
        "start": 44,
        "end": 44,
        "column": {
          "start": 15,
          "end": 55
        },
        "content": "db.QueryContext(context.Background(), q)"
      },
      "parent_line_number": 44,
      "snippet": "db.QueryContext(context.Background(), q)",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_2",
      "old_fingerprint": "a93104166356c0a2709944f5e9659abf_2",
      "code_extract": "\\trows, err := db.QueryContext(context.Background(), q)"
    },
    {
      "cwe_ids": [
        "89"
      ],
      "id": "go_gosec_sql_concat_sqli",
      "title": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
      "description": "## Description\\n\\nSQL Injection represents a severe vulnerability that can culminate in the compromise of data or entire systems. When SQL query strings are crafted dynamically based on user inputs, there's potential for malicious users to manipulate the logic of the SQL statement. Such tampering could provide adversaries unauthorized access to sensitive data or even allow them to execute system-level operations or code.\\n\\n## Remediations\\n\\n✅ Use Parameterized Queries\\n\\nAlways opt for parameterized queries over dynamically generated SQL queries to prevent SQL injection.\\n\\n\`\`\`go\\nrows, err := db.Query(\\"SELECT * FROM users WHERE userName = ?\\", userName)\\nif err != nil {\\n    return nil, err\\n}\\ndefer rows.Close()\\nfor rows.Next() {\\n  // ... process rows\\n}\\n\`\`\`\\n\\n✅ Avoid Direct User Input in Dynamic Queries\\n\\nIf there's an absolute need to formulate dynamic queries, ensure that direct user input is never utilized. Instead, leverage a map or dictionary containing valid values and determine them through a user-provided key.\\n\\nFor instance, certain database drivers do not support parameterized queries for operators like \`>\` or \`<\`. Instead of directly using user-input values, allow users to provide substitutes like \`gt\` for \`>\` and \`lt\` for \`<\`. Subsequently, use these alphabetical inputs to retrieve the actual operators for your query. Implement a similar approach for queries requiring non-parameterizable column or table names.\\n\\n## Resources\\n\\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_sql_concat_sqli",
      "line_number": 62,
      "full_filename": "/tmp/bearer-scan/main2.go",
      "filename": ".",
      "source": {
        "start": 62,
        "end": 62,
        "column": {
          "start": 15,
          "end": 55
        }
      },
      "sink": {
        "start": 62,
        "end": 62,
        "column": {
          "start": 15,
          "end": 55
        },
        "content": "tx.QueryContext(context.Background(), q)"
      },
      "parent_line_number": 62,
      "snippet": "tx.QueryContext(context.Background(), q)",
      "fingerprint": "ca1a3415f7df18be8dec85c9d74eb890_3",
      "old_fingerprint": "a93104166356c0a2709944f5e9659abf_3",
      "code_extract": "\\trows, err := tx.QueryContext(context.Background(), q)"
    }
  ]
}"
`;
