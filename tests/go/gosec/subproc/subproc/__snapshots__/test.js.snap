// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`go_gosec_subproc_subproc test 1`] = `
"{
  "high": [
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 21,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 21,
        "end": 21,
        "column": {
          "start": 9,
          "end": 67
        }
      },
      "sink": {
        "start": 21,
        "end": 21,
        "column": {
          "start": 9,
          "end": 67
        },
        "content": "exec.CommandContext(context.Background(), os.Args[0], \\"5\\")"
      },
      "parent_line_number": 21,
      "snippet": "exec.CommandContext(context.Background(), os.Args[0], \\"5\\")",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_0",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_0",
      "code_extract": "\\terr := exec.CommandContext(context.Background(), os.Args[0], \\"5\\").Run()"
    },
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 30,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 30,
        "end": 30,
        "column": {
          "start": 9,
          "end": 31
        }
      },
      "sink": {
        "start": 30,
        "end": 30,
        "column": {
          "start": 9,
          "end": 31
        },
        "content": "exec.Command(run, \\"5\\")"
      },
      "parent_line_number": 30,
      "snippet": "exec.Command(run, \\"5\\")",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_1",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_1",
      "code_extract": "\\tcmd := exec.Command(run, \\"5\\")"
    },
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 41,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 41,
        "end": 41,
        "column": {
          "start": 9,
          "end": 35
        }
      },
      "sink": {
        "start": 41,
        "end": 41,
        "column": {
          "start": 9,
          "end": 35
        },
        "content": "exec.Command(command, \\"5\\")"
      },
      "parent_line_number": 41,
      "snippet": "exec.Command(command, \\"5\\")",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_2",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_2",
      "code_extract": "\\tcmd := exec.Command(command, \\"5\\")"
    },
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 55,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 55,
        "end": 55,
        "column": {
          "start": 9,
          "end": 24
        }
      },
      "sink": {
        "start": 55,
        "end": 55,
        "column": {
          "start": 9,
          "end": 24
        },
        "content": "exec.Command(c)"
      },
      "parent_line_number": 55,
      "snippet": "exec.Command(c)",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_3",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_3",
      "code_extract": "\\tcmd := exec.Command(c)"
    },
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 62,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 62,
        "end": 62,
        "column": {
          "start": 8,
          "end": 23
        }
      },
      "sink": {
        "start": 62,
        "end": 62,
        "column": {
          "start": 8,
          "end": 23
        },
        "content": "exec.Command(a)"
      },
      "parent_line_number": 62,
      "snippet": "exec.Command(a)",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_4",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_4",
      "code_extract": "\\tcmd = exec.Command(a)"
    },
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 83,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 83,
        "end": 83,
        "column": {
          "start": 12,
          "end": 54
        }
      },
      "sink": {
        "start": 83,
        "end": 83,
        "column": {
          "start": 12,
          "end": 54
        },
        "content": "syscall.ForkExec(command, []string{}, nil)"
      },
      "parent_line_number": 83,
      "snippet": "syscall.ForkExec(command, []string{}, nil)",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_5",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_5",
      "code_extract": "\\t_, err := syscall.ForkExec(command, []string{}, nil)"
    },
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 94,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 94,
        "end": 94,
        "column": {
          "start": 15,
          "end": 61
        }
      },
      "sink": {
        "start": 94,
        "end": 94,
        "column": {
          "start": 15,
          "end": 61
        },
        "content": "syscall.StartProcess(command, []string{}, nil)"
      },
      "parent_line_number": 94,
      "snippet": "syscall.StartProcess(command, []string{}, nil)",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_6",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_6",
      "code_extract": "\\t_, _, err := syscall.StartProcess(command, []string{}, nil)"
    },
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 117,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 117,
        "end": 117,
        "column": {
          "start": 9,
          "end": 67
        }
      },
      "sink": {
        "start": 117,
        "end": 117,
        "column": {
          "start": 9,
          "end": 67
        },
        "content": "exec.CommandContext(context.Background(), os.Args[0], \\"5\\")"
      },
      "parent_line_number": 117,
      "snippet": "exec.CommandContext(context.Background(), os.Args[0], \\"5\\")",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_7",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_7",
      "code_extract": "\\terr := exec.CommandContext(context.Background(), os.Args[0], \\"5\\").Run()"
    },
    {
      "cwe_ids": [
        "94"
      ],
      "id": "go_gosec_subproc_subproc",
      "title": "Unsanitized user input in OS command",
      "description": "## Description\\n\\nOS command injection is a severe security vulnerability that occurs when an application incorrectly processes user input. This flaw can allow attackers to execute arbitrary commands on the host operating system, potentially leading to a full system compromise.\\n\\n## Remediations\\n\\nPrevent OS command injection by adhering to the following practices:\\n\\n❌ Avoid Direct User Input\\n\\nDo not use user-supplied information for constructing OS commands or command-line arguments, as this can lead to command injection vulnerabilities.\\n\\n✅ Implement Input Validation\\n\\nEnsure that any user input is validated against a set of strict rules to ensure it does not contain malicious characters or patterns.\\n\\n✅ Use Hardcoded Arguments\\n\\nWhen invoking OS commands, use a hardcoded set of arguments to ensure that user input cannot alter the command's behavior.\\n\\n✅ Utilize Temporary Files Securely\\n\\nWhen dealing with files, create temporary files in a restricted directory, avoiding the use of user-supplied filenames.\\n\\n✅ Employ Native Libraries\\n\\nWhere possible, use native libraries or features of the programming language instead of invoking shell commands, which can be safer and more efficient.\\n\\n\`\`\`go\\nimport (\\n    \\"io/ioutil\\"\\n    \\"os/exec\\"\\n    \\"log\\"\\n)\\n\\nfunc main() {\\n    userData := []byte(\\"user data\\")\\n\\n    // Create a temporary file in a secure, application-specific directory\\n    f, err := ioutil.TempFile(\\"/var/app/restricted\\", \\"temp-*.dat\\")\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Write user data to the temporary file\\n    if _, err := f.Write(userData); err != nil {\\n        f.Close()\\n        log.Fatal(err)\\n    }\\n\\n    // Close the file handle\\n    if err := f.Close(); err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // Execute a command using the temporary file, avoiding direct user input for filenames\\n    out, err := exec.Command(\\"/bin/cat\\", f.Name()).Output()\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n    // Output can be used for further processing\\n}\\n\`\`\`\\n\\n## Resources\\n\\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc",
      "line_number": 127,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 127,
        "end": 127,
        "column": {
          "start": 14,
          "end": 51
        }
      },
      "sink": {
        "start": 127,
        "end": 127,
        "column": {
          "start": 14,
          "end": 51
        },
        "content": "exec.Command(\\"sh\\", \\"-c\\", commandLine)"
      },
      "parent_line_number": 127,
      "snippet": "exec.Command(\\"sh\\", \\"-c\\", commandLine)",
      "fingerprint": "9f7b927d8c9e1a6c92e17fb2d6db3b18_8",
      "old_fingerprint": "c7b747c46d0e283c15b7386a8c801ea8_8",
      "code_extract": "\\tres, err := exec.Command(\\"sh\\", \\"-c\\", commandLine).Output()"
    }
  ]
}"
`;
