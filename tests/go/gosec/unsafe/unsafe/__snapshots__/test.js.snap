// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`go_gosec_unsafe_unsafe test 1`] = `
"{
  "low": [
    {
      "cwe_ids": [
        "242"
      ],
      "id": "go_gosec_unsafe_unsafe",
      "title": "Usage of vulnerable 'unsafe' package",
      "description": "## Description\\n\\nThe Go programming language features the \`unsafe\` package which grants low-level memory management capabilities, inclusive of direct memory access and pointer manipulation. Though the \`unsafe\` package can be quite potent, its usage sidesteps the Go compiler's type safety checks. This can lead to an array of security vulnerabilities and unpredictable system behavior.\\n\\n## Remediations\\n\\n✅ Avoid \`unsafe\` Unless Absolutely Necessary\\n\\nThe overarching guidance here is to steer clear of the \`unsafe\` package unless there's an absolute necessity for its functions. When opting for low-level memory operations, ensure that their implications are well-understood and that their deployment is preceded by rigorous testing.\\n\\n✅ Be Wary of Buffer Overflows\\n\\nDirect manipulation of memory can lead to buffer overflows, potentially enabling unauthorized code execution. Ensure buffer boundaries are always respected.\\n\\n✅ Avoid Use After Free\\n\\nAccessing memory that has already been freed can result in unintended code execution or unpredictable behaviors. Ensure that once memory has been freed, it isn't accessed further.\\n\\n✅ Prevent Information/Memory Leaks\\n\\nUnintended memory retention or unintended disclosure of information in memory can occur when using unsafe functions. This can compromise other security defenses or lead to system failures due to exhausted memory. Regularly review and audit your code to check for such leaks.\\n\\n## Resources\\n\\n- [Buffer Overflows - OWASP](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\\n- [Using Freed Memory - OWASP](https://owasp.org/www-community/vulnerabilities/Using_freed_memory)\\n- [Memory Leaks - OWASP](https://owasp.org/www-community/vulnerabilities/Memory_leak)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_unsafe_unsafe",
      "line_number": 19,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 19,
        "end": 19,
        "column": {
          "start": 53,
          "end": 79
        }
      },
      "sink": {
        "start": 19,
        "end": 19,
        "column": {
          "start": 27,
          "end": 49
        },
        "content": "unsafe.Pointer(intPtr)"
      },
      "parent_line_number": 19,
      "snippet": "unsafe.Pointer(intPtr)",
      "fingerprint": "db1c9d5a44e2bb335daa53a4b208a682_0",
      "old_fingerprint": "0787e01535ffb4d4e7052dfb097bcfdb_0",
      "code_extract": "\\taddressHolder := uintptr(unsafe.Pointer(intPtr)) + unsafe.Sizeof(intArray[0])"
    },
    {
      "cwe_ids": [
        "242"
      ],
      "id": "go_gosec_unsafe_unsafe",
      "title": "Usage of vulnerable 'unsafe' package",
      "description": "## Description\\n\\nThe Go programming language features the \`unsafe\` package which grants low-level memory management capabilities, inclusive of direct memory access and pointer manipulation. Though the \`unsafe\` package can be quite potent, its usage sidesteps the Go compiler's type safety checks. This can lead to an array of security vulnerabilities and unpredictable system behavior.\\n\\n## Remediations\\n\\n✅ Avoid \`unsafe\` Unless Absolutely Necessary\\n\\nThe overarching guidance here is to steer clear of the \`unsafe\` package unless there's an absolute necessity for its functions. When opting for low-level memory operations, ensure that their implications are well-understood and that their deployment is preceded by rigorous testing.\\n\\n✅ Be Wary of Buffer Overflows\\n\\nDirect manipulation of memory can lead to buffer overflows, potentially enabling unauthorized code execution. Ensure buffer boundaries are always respected.\\n\\n✅ Avoid Use After Free\\n\\nAccessing memory that has already been freed can result in unintended code execution or unpredictable behaviors. Ensure that once memory has been freed, it isn't accessed further.\\n\\n✅ Prevent Information/Memory Leaks\\n\\nUnintended memory retention or unintended disclosure of information in memory can occur when using unsafe functions. This can compromise other security defenses or lead to system failures due to exhausted memory. Regularly review and audit your code to check for such leaks.\\n\\n## Resources\\n\\n- [Buffer Overflows - OWASP](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\\n- [Using Freed Memory - OWASP](https://owasp.org/www-community/vulnerabilities/Using_freed_memory)\\n- [Memory Leaks - OWASP](https://owasp.org/www-community/vulnerabilities/Memory_leak)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_unsafe_unsafe",
      "line_number": 20,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 20,
        "end": 20,
        "column": {
          "start": 18,
          "end": 47
        }
      },
      "sink": {
        "start": 20,
        "end": 20,
        "column": {
          "start": 18,
          "end": 47
        },
        "content": "unsafe.Pointer(addressHolder)"
      },
      "parent_line_number": 20,
      "snippet": "unsafe.Pointer(addressHolder)",
      "fingerprint": "db1c9d5a44e2bb335daa53a4b208a682_2",
      "old_fingerprint": "0787e01535ffb4d4e7052dfb097bcfdb_2",
      "code_extract": "\\tintPtr = (*int)(unsafe.Pointer(addressHolder))"
    }
  ]
}"
`;
