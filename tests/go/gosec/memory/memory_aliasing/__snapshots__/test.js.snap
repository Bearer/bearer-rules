// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`go_gosec_memory_memory_aliasing test 1`] = `
"{
  "low": [
    {
      "cwe_ids": [
        "118"
      ],
      "id": "go_gosec_memory_memory_aliasing",
      "title": "Incorrect access of indexable resource (Range Error)",
      "description": "## Description\\n\\nGo's \`for ... range\` constructs allocate a single iteration variable for the loop's duration, which can cause confusion when addresses of this variable are stored or used beyond a single iteration. Since the iteration variable's address remains constant, subsequent iterations overwrite the previously referenced values, leading to unexpected results, particularly when using go routines or deferred functions within the loop.\\n\\n## Remediations\\n\\n✅ Create a New Variable Inside the Loop\\n\\nDeclare a new local variable within the loop's scope to hold the iteration value. This ensures a unique address is used for each iteration.\\n\\n\`\`\`go\\nfor _, n := range []someStruct{{1}, {2}, {3}, {4}} {\\n  localVar := n\\n  // Use localVar instead of n\\n}\\n\`\`\`\\n\\n✅ Use Indexed Addressing\\n\\nInstead of the iteration variable, directly reference the indexed element within the array or slice.\\n\\n\`\`\`go\\nfor i := range mySlice {\\n  // Use &mySlice[i] to obtain a stable address\\n}\\n\`\`\`\\n\\n❌ Do Not Store the Address of the Iteration Variable\\n\\nAvoid taking the address of the iteration variable and storing it, as it leads to all references pointing to the same memory location.\\n\\n❌ Avoid Using the Iteration Variable's Address in Goroutines\\n\\nUsing the iteration variable's address directly in goroutines can cause race conditions or logical errors, as the variable's value may change before the goroutine accesses it.\\n\\n## Resources\\n\\n- [Go For Statements](https://go.dev/ref/spec#For_statements)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_memory_memory_aliasing",
      "line_number": 27,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 27,
        "end": 27,
        "column": {
          "start": 16,
          "end": 21
        }
      },
      "sink": {
        "start": 27,
        "end": 27,
        "column": {
          "start": 16,
          "end": 21
        },
        "content": "&item"
      },
      "parent_line_number": 27,
      "snippet": "&item",
      "fingerprint": "48f24a9e016ac12602af8f93ed78cac9_0",
      "old_fingerprint": "f4242521fe214000ea523c0029908b3d_0",
      "code_extract": "\\t\\tappendVector(&item)"
    },
    {
      "cwe_ids": [
        "118"
      ],
      "id": "go_gosec_memory_memory_aliasing",
      "title": "Incorrect access of indexable resource (Range Error)",
      "description": "## Description\\n\\nGo's \`for ... range\` constructs allocate a single iteration variable for the loop's duration, which can cause confusion when addresses of this variable are stored or used beyond a single iteration. Since the iteration variable's address remains constant, subsequent iterations overwrite the previously referenced values, leading to unexpected results, particularly when using go routines or deferred functions within the loop.\\n\\n## Remediations\\n\\n✅ Create a New Variable Inside the Loop\\n\\nDeclare a new local variable within the loop's scope to hold the iteration value. This ensures a unique address is used for each iteration.\\n\\n\`\`\`go\\nfor _, n := range []someStruct{{1}, {2}, {3}, {4}} {\\n  localVar := n\\n  // Use localVar instead of n\\n}\\n\`\`\`\\n\\n✅ Use Indexed Addressing\\n\\nInstead of the iteration variable, directly reference the indexed element within the array or slice.\\n\\n\`\`\`go\\nfor i := range mySlice {\\n  // Use &mySlice[i] to obtain a stable address\\n}\\n\`\`\`\\n\\n❌ Do Not Store the Address of the Iteration Variable\\n\\nAvoid taking the address of the iteration variable and storing it, as it leads to all references pointing to the same memory location.\\n\\n❌ Avoid Using the Iteration Variable's Address in Goroutines\\n\\nUsing the iteration variable's address directly in goroutines can cause race conditions or logical errors, as the variable's value may change before the goroutine accesses it.\\n\\n## Resources\\n\\n- [Go For Statements](https://go.dev/ref/spec#For_statements)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_memory_memory_aliasing",
      "line_number": 54,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 54,
        "end": 54,
        "column": {
          "start": 27,
          "end": 29
        }
      },
      "sink": {
        "start": 54,
        "end": 54,
        "column": {
          "start": 27,
          "end": 29
        },
        "content": "&s"
      },
      "parent_line_number": 54,
      "snippet": "&s",
      "fingerprint": "48f24a9e016ac12602af8f93ed78cac9_1",
      "old_fingerprint": "f4242521fe214000ea523c0029908b3d_1",
      "code_extract": "\\t\\tfmt.Println(\\"%d %p\\", i, &s)"
    }
  ]
}"
`;
