// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`go_gosec_memory_integer_overflow test 1`] = `
"{
  "low": [
    {
      "cwe_ids": [
        "190"
      ],
      "id": "go_gosec_memory_integer_overflow",
      "title": "Integer overflow or wraparound",
      "description": "## Description\\n\\nIn Golang, the size of the \`int\` type is contingent on the system architecture of where the application operates. Specifically, on 32-bit systems, \`int\` is 32-bit, whereas on 64-bit systems, \`int\` is 64-bit. There's a risk of integer overflow when invoking \`strconv.Atoi\` with a substantially large number, particularly if the returned \`int\` is type-converted into a smaller type like \`int32\` or \`int16\`. Such overflow can trigger unpredictable application behaviors depending on the usage of the resultant value.\\n\\n## Remediations\\n\\n✅ Validate Value Before Type Conversion\\n\\nBefore performing any type conversion, it's crucial to ensure that the value fetched from \`strconv.Atoi\` can be accommodated in the targeted integer type.\\n\\n\`\`\`go\\nbigValue, _ := strconv.Atoi(\\"32768\\")\\nif bigValue > math.MaxInt16 {\\n    log.Fatal(\\"value too large to fit in int16\\")\\n}\\nvalue := int16(bigValue)\\nfmt.Println(value)\\n\`\`\`\\n\\n## Resources\\n\\n- [Integer Min/Max Constants in Go](https://pkg.go.dev/math#pkg-constants)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_memory_integer_overflow",
      "line_number": 14,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 14,
        "end": 14,
        "column": {
          "start": 11,
          "end": 26
        }
      },
      "sink": {
        "start": 14,
        "end": 14,
        "column": {
          "start": 11,
          "end": 26
        },
        "content": "int32(bigValue)"
      },
      "parent_line_number": 14,
      "snippet": "int32(bigValue)",
      "fingerprint": "b5f27376bfb10d4674975a3b925e7fa8_0",
      "old_fingerprint": "eb680ca9957c3112000a5ec4865bdca7_0",
      "code_extract": "\\tvalue := int32(bigValue)"
    },
    {
      "cwe_ids": [
        "190"
      ],
      "id": "go_gosec_memory_integer_overflow",
      "title": "Integer overflow or wraparound",
      "description": "## Description\\n\\nIn Golang, the size of the \`int\` type is contingent on the system architecture of where the application operates. Specifically, on 32-bit systems, \`int\` is 32-bit, whereas on 64-bit systems, \`int\` is 64-bit. There's a risk of integer overflow when invoking \`strconv.Atoi\` with a substantially large number, particularly if the returned \`int\` is type-converted into a smaller type like \`int32\` or \`int16\`. Such overflow can trigger unpredictable application behaviors depending on the usage of the resultant value.\\n\\n## Remediations\\n\\n✅ Validate Value Before Type Conversion\\n\\nBefore performing any type conversion, it's crucial to ensure that the value fetched from \`strconv.Atoi\` can be accommodated in the targeted integer type.\\n\\n\`\`\`go\\nbigValue, _ := strconv.Atoi(\\"32768\\")\\nif bigValue > math.MaxInt16 {\\n    log.Fatal(\\"value too large to fit in int16\\")\\n}\\nvalue := int16(bigValue)\\nfmt.Println(value)\\n\`\`\`\\n\\n## Resources\\n\\n- [Integer Min/Max Constants in Go](https://pkg.go.dev/math#pkg-constants)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_memory_integer_overflow",
      "line_number": 20,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 20,
        "end": 20,
        "column": {
          "start": 5,
          "end": 20
        }
      },
      "sink": {
        "start": 20,
        "end": 20,
        "column": {
          "start": 5,
          "end": 20
        },
        "content": "int16(bigValue)"
      },
      "parent_line_number": 20,
      "snippet": "int16(bigValue)",
      "fingerprint": "b5f27376bfb10d4674975a3b925e7fa8_1",
      "old_fingerprint": "eb680ca9957c3112000a5ec4865bdca7_1",
      "code_extract": "\\tif int16(bigValue) < 0 {"
    }
  ]
}"
`;
