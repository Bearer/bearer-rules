// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`go_gosec_filesystem_filereadtaint test 1`] = `
"{
  "low": [
    {
      "cwe_ids": [
        "327"
      ],
      "id": "go_gosec_filesystem_filereadtaint",
      "title": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
      "description": "## Description\\n\\nThe application dynamically constructs file or path information. If the path information comes from user input, it could be abused to read sensitive files, access other users data or aid in exploitation to gain further system access.\\n\\nUser input should never be used in constructing paths or files for interacting with the filesystem. This includes filenames supplied by user uploads or downloads.\\n\\n## Remediations\\n\\n✅ If possible, consider hashing user input or replacing it with unique values.\\n\\n✅ Additionally, use \`filepath.Base\` to only use the filename and not path information.\\n\\nAlways validate the full path prior to opening or writing to any file.\\n\\n\`\`\`go\\ntype userData struct {\\n    id           string\\n    userFilename string\\n}\\n\\nfunc newUserData(userFilename string) userData {\\n    return userData{\\n        id:           randomFileID(), // random id as the filename\\n        userFilename: userFilename,\\n    }\\n}\\n\\n// randomFileID generates a random id, to be used as a filename\\nfunc randomFileID() string {\\n    id := make([]byte, 16)\\n    if _, err := io.ReadFull(rand.Reader, id); err != nil {\\n        log.Fatal(err)\\n    }\\n    return hex.EncodeToString(id)\\n}\\n\\nfunc main() {\\n\\n    // user input, saved only as a reference\\n    data := newUserData(\\"../../possibly/malicious\\")\\n\\n    // restrict all file access to this path\\n    const basePath = \\"/tmp/\\"\\n\\n    // resolve the full path, but only use our random generated id\\n    resolvedPath, err := filepath.Join(basePath, filepath.Base(data.id))\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // verify the path is prefixed with our basePath\\n    if !strings.HasPrefix(resolvedPath, basePath) {\\n        log.Fatal(\\"path does not start with basePath\\")\\n    }\\n    // process / work with file\\n}\\n\`\`\`\\n\\n## Resources\\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint",
      "line_number": 19,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 19,
        "end": 19,
        "column": {
          "start": 15,
          "end": 33
        }
      },
      "sink": {
        "start": 19,
        "end": 19,
        "column": {
          "start": 15,
          "end": 33
        },
        "content": "ioutil.ReadFile(f)"
      },
      "parent_line_number": 19,
      "snippet": "ioutil.ReadFile(f)",
      "fingerprint": "4cbdcba5327691a5836bdf26ca7b0f5d_0",
      "old_fingerprint": "74ca07036b660b9689e4fe7febfbed2b_0",
      "code_extract": "\\tbody, err := ioutil.ReadFile(f)"
    },
    {
      "cwe_ids": [
        "327"
      ],
      "id": "go_gosec_filesystem_filereadtaint",
      "title": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
      "description": "## Description\\n\\nThe application dynamically constructs file or path information. If the path information comes from user input, it could be abused to read sensitive files, access other users data or aid in exploitation to gain further system access.\\n\\nUser input should never be used in constructing paths or files for interacting with the filesystem. This includes filenames supplied by user uploads or downloads.\\n\\n## Remediations\\n\\n✅ If possible, consider hashing user input or replacing it with unique values.\\n\\n✅ Additionally, use \`filepath.Base\` to only use the filename and not path information.\\n\\nAlways validate the full path prior to opening or writing to any file.\\n\\n\`\`\`go\\ntype userData struct {\\n    id           string\\n    userFilename string\\n}\\n\\nfunc newUserData(userFilename string) userData {\\n    return userData{\\n        id:           randomFileID(), // random id as the filename\\n        userFilename: userFilename,\\n    }\\n}\\n\\n// randomFileID generates a random id, to be used as a filename\\nfunc randomFileID() string {\\n    id := make([]byte, 16)\\n    if _, err := io.ReadFull(rand.Reader, id); err != nil {\\n        log.Fatal(err)\\n    }\\n    return hex.EncodeToString(id)\\n}\\n\\nfunc main() {\\n\\n    // user input, saved only as a reference\\n    data := newUserData(\\"../../possibly/malicious\\")\\n\\n    // restrict all file access to this path\\n    const basePath = \\"/tmp/\\"\\n\\n    // resolve the full path, but only use our random generated id\\n    resolvedPath, err := filepath.Join(basePath, filepath.Base(data.id))\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // verify the path is prefixed with our basePath\\n    if !strings.HasPrefix(resolvedPath, basePath) {\\n        log.Fatal(\\"path does not start with basePath\\")\\n    }\\n    // process / work with file\\n}\\n\`\`\`\\n\\n## Resources\\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint",
      "line_number": 30,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 30,
        "end": 30,
        "column": {
          "start": 13,
          "end": 27
        }
      },
      "sink": {
        "start": 30,
        "end": 30,
        "column": {
          "start": 13,
          "end": 27
        },
        "content": "os.Open(title)"
      },
      "parent_line_number": 30,
      "snippet": "os.Open(title)",
      "fingerprint": "4cbdcba5327691a5836bdf26ca7b0f5d_1",
      "old_fingerprint": "74ca07036b660b9689e4fe7febfbed2b_1",
      "code_extract": "\\t\\tf, err := os.Open(title)"
    },
    {
      "cwe_ids": [
        "327"
      ],
      "id": "go_gosec_filesystem_filereadtaint",
      "title": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
      "description": "## Description\\n\\nThe application dynamically constructs file or path information. If the path information comes from user input, it could be abused to read sensitive files, access other users data or aid in exploitation to gain further system access.\\n\\nUser input should never be used in constructing paths or files for interacting with the filesystem. This includes filenames supplied by user uploads or downloads.\\n\\n## Remediations\\n\\n✅ If possible, consider hashing user input or replacing it with unique values.\\n\\n✅ Additionally, use \`filepath.Base\` to only use the filename and not path information.\\n\\nAlways validate the full path prior to opening or writing to any file.\\n\\n\`\`\`go\\ntype userData struct {\\n    id           string\\n    userFilename string\\n}\\n\\nfunc newUserData(userFilename string) userData {\\n    return userData{\\n        id:           randomFileID(), // random id as the filename\\n        userFilename: userFilename,\\n    }\\n}\\n\\n// randomFileID generates a random id, to be used as a filename\\nfunc randomFileID() string {\\n    id := make([]byte, 16)\\n    if _, err := io.ReadFull(rand.Reader, id); err != nil {\\n        log.Fatal(err)\\n    }\\n    return hex.EncodeToString(id)\\n}\\n\\nfunc main() {\\n\\n    // user input, saved only as a reference\\n    data := newUserData(\\"../../possibly/malicious\\")\\n\\n    // restrict all file access to this path\\n    const basePath = \\"/tmp/\\"\\n\\n    // resolve the full path, but only use our random generated id\\n    resolvedPath, err := filepath.Join(basePath, filepath.Base(data.id))\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // verify the path is prefixed with our basePath\\n    if !strings.HasPrefix(resolvedPath, basePath) {\\n        log.Fatal(\\"path does not start with basePath\\")\\n    }\\n    // process / work with file\\n}\\n\`\`\`\\n\\n## Resources\\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint",
      "line_number": 46,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 46,
        "end": 46,
        "column": {
          "start": 13,
          "end": 60
        }
      },
      "sink": {
        "start": 46,
        "end": 46,
        "column": {
          "start": 13,
          "end": 60
        },
        "content": "os.OpenFile(title, os.O_RDWR|os.O_CREATE, 0755)"
      },
      "parent_line_number": 46,
      "snippet": "os.OpenFile(title, os.O_RDWR|os.O_CREATE, 0755)",
      "fingerprint": "4cbdcba5327691a5836bdf26ca7b0f5d_2",
      "old_fingerprint": "74ca07036b660b9689e4fe7febfbed2b_2",
      "code_extract": "\\t\\tf, err := os.OpenFile(title, os.O_RDWR|os.O_CREATE, 0755)"
    },
    {
      "cwe_ids": [
        "327"
      ],
      "id": "go_gosec_filesystem_filereadtaint",
      "title": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
      "description": "## Description\\n\\nThe application dynamically constructs file or path information. If the path information comes from user input, it could be abused to read sensitive files, access other users data or aid in exploitation to gain further system access.\\n\\nUser input should never be used in constructing paths or files for interacting with the filesystem. This includes filenames supplied by user uploads or downloads.\\n\\n## Remediations\\n\\n✅ If possible, consider hashing user input or replacing it with unique values.\\n\\n✅ Additionally, use \`filepath.Base\` to only use the filename and not path information.\\n\\nAlways validate the full path prior to opening or writing to any file.\\n\\n\`\`\`go\\ntype userData struct {\\n    id           string\\n    userFilename string\\n}\\n\\nfunc newUserData(userFilename string) userData {\\n    return userData{\\n        id:           randomFileID(), // random id as the filename\\n        userFilename: userFilename,\\n    }\\n}\\n\\n// randomFileID generates a random id, to be used as a filename\\nfunc randomFileID() string {\\n    id := make([]byte, 16)\\n    if _, err := io.ReadFull(rand.Reader, id); err != nil {\\n        log.Fatal(err)\\n    }\\n    return hex.EncodeToString(id)\\n}\\n\\nfunc main() {\\n\\n    // user input, saved only as a reference\\n    data := newUserData(\\"../../possibly/malicious\\")\\n\\n    // restrict all file access to this path\\n    const basePath = \\"/tmp/\\"\\n\\n    // resolve the full path, but only use our random generated id\\n    resolvedPath, err := filepath.Join(basePath, filepath.Base(data.id))\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // verify the path is prefixed with our basePath\\n    if !strings.HasPrefix(resolvedPath, basePath) {\\n        log.Fatal(\\"path does not start with basePath\\")\\n    }\\n    // process / work with file\\n}\\n\`\`\`\\n\\n## Resources\\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint",
      "line_number": 61,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 61,
        "end": 61,
        "column": {
          "start": 15,
          "end": 44
        }
      },
      "sink": {
        "start": 61,
        "end": 61,
        "column": {
          "start": 15,
          "end": 44
        },
        "content": "ioutil.ReadFile(\\"/tmp/\\" + f2)"
      },
      "parent_line_number": 61,
      "snippet": "ioutil.ReadFile(\\"/tmp/\\" + f2)",
      "fingerprint": "4cbdcba5327691a5836bdf26ca7b0f5d_3",
      "old_fingerprint": "74ca07036b660b9689e4fe7febfbed2b_3",
      "code_extract": "\\tbody, err := ioutil.ReadFile(\\"/tmp/\\" + f2)"
    },
    {
      "cwe_ids": [
        "327"
      ],
      "id": "go_gosec_filesystem_filereadtaint",
      "title": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
      "description": "## Description\\n\\nThe application dynamically constructs file or path information. If the path information comes from user input, it could be abused to read sensitive files, access other users data or aid in exploitation to gain further system access.\\n\\nUser input should never be used in constructing paths or files for interacting with the filesystem. This includes filenames supplied by user uploads or downloads.\\n\\n## Remediations\\n\\n✅ If possible, consider hashing user input or replacing it with unique values.\\n\\n✅ Additionally, use \`filepath.Base\` to only use the filename and not path information.\\n\\nAlways validate the full path prior to opening or writing to any file.\\n\\n\`\`\`go\\ntype userData struct {\\n    id           string\\n    userFilename string\\n}\\n\\nfunc newUserData(userFilename string) userData {\\n    return userData{\\n        id:           randomFileID(), // random id as the filename\\n        userFilename: userFilename,\\n    }\\n}\\n\\n// randomFileID generates a random id, to be used as a filename\\nfunc randomFileID() string {\\n    id := make([]byte, 16)\\n    if _, err := io.ReadFull(rand.Reader, id); err != nil {\\n        log.Fatal(err)\\n    }\\n    return hex.EncodeToString(id)\\n}\\n\\nfunc main() {\\n\\n    // user input, saved only as a reference\\n    data := newUserData(\\"../../possibly/malicious\\")\\n\\n    // restrict all file access to this path\\n    const basePath = \\"/tmp/\\"\\n\\n    // resolve the full path, but only use our random generated id\\n    resolvedPath, err := filepath.Join(basePath, filepath.Base(data.id))\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // verify the path is prefixed with our basePath\\n    if !strings.HasPrefix(resolvedPath, basePath) {\\n        log.Fatal(\\"path does not start with basePath\\")\\n    }\\n    // process / work with file\\n}\\n\`\`\`\\n\\n## Resources\\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint",
      "line_number": 73,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 73,
        "end": 73,
        "column": {
          "start": 12,
          "end": 57
        }
      },
      "sink": {
        "start": 73,
        "end": 73,
        "column": {
          "start": 12,
          "end": 57
        },
        "content": "os.Open(filepath.Join(\\"/tmp/service/\\", file))"
      },
      "parent_line_number": 73,
      "snippet": "os.Open(filepath.Join(\\"/tmp/service/\\", file))",
      "fingerprint": "4cbdcba5327691a5836bdf26ca7b0f5d_4",
      "old_fingerprint": "74ca07036b660b9689e4fe7febfbed2b_4",
      "code_extract": "\\tf, err := os.Open(filepath.Join(\\"/tmp/service/\\", file))"
    },
    {
      "cwe_ids": [
        "327"
      ],
      "id": "go_gosec_filesystem_filereadtaint",
      "title": "Improper limitation of a pathname to a restricted directory ('Path Traversal')",
      "description": "## Description\\n\\nThe application dynamically constructs file or path information. If the path information comes from user input, it could be abused to read sensitive files, access other users data or aid in exploitation to gain further system access.\\n\\nUser input should never be used in constructing paths or files for interacting with the filesystem. This includes filenames supplied by user uploads or downloads.\\n\\n## Remediations\\n\\n✅ If possible, consider hashing user input or replacing it with unique values.\\n\\n✅ Additionally, use \`filepath.Base\` to only use the filename and not path information.\\n\\nAlways validate the full path prior to opening or writing to any file.\\n\\n\`\`\`go\\ntype userData struct {\\n    id           string\\n    userFilename string\\n}\\n\\nfunc newUserData(userFilename string) userData {\\n    return userData{\\n        id:           randomFileID(), // random id as the filename\\n        userFilename: userFilename,\\n    }\\n}\\n\\n// randomFileID generates a random id, to be used as a filename\\nfunc randomFileID() string {\\n    id := make([]byte, 16)\\n    if _, err := io.ReadFull(rand.Reader, id); err != nil {\\n        log.Fatal(err)\\n    }\\n    return hex.EncodeToString(id)\\n}\\n\\nfunc main() {\\n\\n    // user input, saved only as a reference\\n    data := newUserData(\\"../../possibly/malicious\\")\\n\\n    // restrict all file access to this path\\n    const basePath = \\"/tmp/\\"\\n\\n    // resolve the full path, but only use our random generated id\\n    resolvedPath, err := filepath.Join(basePath, filepath.Base(data.id))\\n    if err != nil {\\n        log.Fatal(err)\\n    }\\n\\n    // verify the path is prefixed with our basePath\\n    if !strings.HasPrefix(resolvedPath, basePath) {\\n        log.Fatal(\\"path does not start with basePath\\")\\n    }\\n    // process / work with file\\n}\\n\`\`\`\\n\\n## Resources\\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\\n",
      "documentation_url": "https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint",
      "line_number": 88,
      "full_filename": "/tmp/bearer-scan/main.go",
      "filename": ".",
      "source": {
        "start": 88,
        "end": 88,
        "column": {
          "start": 15,
          "end": 62
        }
      },
      "sink": {
        "start": 88,
        "end": 88,
        "column": {
          "start": 15,
          "end": 62
        },
        "content": "ioutil.ReadFile(filepath.Join(\\"/var/\\"+dir, f3))"
      },
      "parent_line_number": 88,
      "snippet": "ioutil.ReadFile(filepath.Join(\\"/var/\\"+dir, f3))",
      "fingerprint": "4cbdcba5327691a5836bdf26ca7b0f5d_5",
      "old_fingerprint": "74ca07036b660b9689e4fe7febfbed2b_5",
      "code_extract": "\\tbody, err := ioutil.ReadFile(filepath.Join(\\"/var/\\"+dir, f3))"
    }
  ]
}"
`;
